import os
import hashlib
import pefile
import magic
from transformers import pipeline
from PyPDF2 import PdfReader
from PIL import Image, ExifTags
import zipfile
from mutagen import File as MutagenFile
import requests

# VirusTotal API key (You need to replace this with your own API key)
VIRUSTOTAL_API_KEY = "857c228666f7fbf013f85e7a4a3f80bdaa20e8a0232529f21ef6dad838d0b3d3"

# Original Functions

def calculate_file_hash(file_path, hash_type="md5"):
    """Calculate file hash using the specified hash type."""
    hash_func = getattr(hashlib, hash_type, None)
    if not hash_func:
        return "Invalid hash type."
    
    with open(file_path, 'rb') as f:
        file_data = f.read()
    return hash_func(file_data).hexdigest()


def extract_pe_metadata(file_path):
    """Extract metadata from PE files."""
    try:
        pe = pefile.PE(file_path)
        metadata = {
            "Entry Point": hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint),
            "Image Base": hex(pe.OPTIONAL_HEADER.ImageBase),
            "Number of Sections": pe.FILE_HEADER.NumberOfSections,
            "Machine Type": pefile.MACHINE_TYPE[pe.FILE_HEADER.Machine],
            "Characteristics": hex(pe.FILE_HEADER.Characteristics),
            "Subsystem": pefile.SUBSYSTEM_TYPE[pe.OPTIONAL_HEADER.Subsystem],
            "Size of Image": hex(pe.OPTIONAL_HEADER.SizeOfImage),
            "Size of Headers": hex(pe.OPTIONAL_HEADER.SizeOfHeaders),
            "DLL Characteristics": hex(pe.OPTIONAL_HEADER.DllCharacteristics),
            "Timestamp": hex(pe.FILE_HEADER.TimeDateStamp),
            "Section Info": [{"Name": section.Name.decode().strip(),
                              "Virtual Size": hex(section.Misc_VirtualSize),
                              "Raw Size": hex(section.SizeOfRawData)} for section in pe.sections],
            "Imports": [{"DLL": entry.dll.decode(),
                         "Functions": [imp.name.decode() for imp in entry.imports if imp.name] }
                        for entry in pe.DIRECTORY_ENTRY_IMPORT],
            "Exports": [exp.name.decode() for exp in getattr(pe, 'DIRECTORY_ENTRY_EXPORT', {}).symbols or []]
        }
        return metadata
    except Exception as e:
        return {"Error": str(e)}


def detect_suspicious_strings(file_path):
    """Search for suspicious strings in the file."""
    keywords_file_path = r"C:\Users\samia\OneDrive\Desktop\New folder\suspicious_strings.txt"  # Hardcoded path to keywords file

    try:
        # Read the suspicious keywords from the file
        with open(keywords_file_path, 'r', encoding='utf-8') as kf:
            suspicious_keywords = [line.strip() for line in kf if line.strip()]

        detected = []
        with open(file_path, 'rb') as f:
            content = f.read().decode(errors='ignore')
            for keyword in suspicious_keywords:
                if keyword.lower() in content.lower():
                    detected.append(keyword)
    except Exception as e:
        detected = [f"Error: {str(e)}"]
    
    return detected


def get_file_type(file_path):
    """Identify the file type using libmagic."""
    try:
        mime = magic.Magic(mime=True)
        return mime.from_file(file_path)
    except Exception as e:
        return f"Error determining file type: {str(e)}"


def analyze_with_llm(strings_to_analyze):
    """Use an LLM to provide insights on suspicious strings."""
    model_pipeline = pipeline("text-classification", model="distilbert-base-uncased-finetuned-sst-2-english")
    results = []
    for string in strings_to_analyze:
        analysis = model_pipeline(string)
        sentiment = analysis[0]['label']
        confidence = analysis[0]['score']
        results.append((string, sentiment, confidence))
    return results


def virus_total_hash_lookup(file_hash):
    """Look up the file hash in VirusTotal."""
    url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
    headers = {
        "x-apikey": VIRUSTOTAL_API_KEY
    }
    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            json_data = response.json()
            if json_data.get('data'):
                attributes = json_data['data']['attributes']
                scan_results = attributes.get('last_analysis_results', {})
                total_detected = sum(1 for result in scan_results.values() if result.get('category') == 'malicious')
                total_scan_count = len(scan_results)
                return {
                    "VirusTotal Scan Count": total_scan_count,
                    "VirusTotal Detected": total_detected,
                    "VirusTotal Scan Results": scan_results
                }
            else:
                return {"Error": "No data found for this hash."}
        elif response.status_code == 404:
            return {"Error": "File hash not found in VirusTotal database (404)."}
        else:
            return {"Error": f"VirusTotal API error: {response.status_code}"}
    except Exception as e:
        return {"Error": str(e)}


# Extended Functions for Other File Types

def extract_pdf_metadata(file_path):
    """Extract metadata from PDF files."""
    try:
        reader = PdfReader(file_path)
        metadata = reader.metadata
        return {key[1:]: value for key, value in metadata.items()} if metadata else {"Error": "No metadata found."}
    except Exception as e:
        return {"Error": str(e)}


def extract_image_metadata(file_path):
    """Extract metadata from image files."""
    try:
        with Image.open(file_path) as img:
            exif_data = img._getexif()  # Raw EXIF data
            if not exif_data:
                return {"Error": "No EXIF metadata found."}
            
            metadata = {ExifTags.TAGS.get(tag, tag): value for tag, value in exif_data.items()}
            return metadata
    except Exception as e:
        return {"Error": str(e)}


def extract_zip_metadata(file_path):
    """Extract metadata and contents of ZIP files."""
    try:
        with zipfile.ZipFile(file_path, 'r') as zf:
            file_list = zf.namelist()
            return {"File Count": len(file_list), "Files": file_list}
    except Exception as e:
        return {"Error": str(e)}


def extract_audio_metadata(file_path):
    """Extract metadata from audio files."""
    try:
        audio = MutagenFile(file_path)
        if not audio:
            return {"Error": "No metadata found."}
        return {key: str(value) for key, value in audio.tags.items()}
    except Exception as e:
        return {"Error": str(e)}


def extract_document_metadata(file_path):
    """Extract metadata from document files (.docx, .xls, .ppt, etc.)."""
    try:
        if file_path.endswith('.docx'):
            from docx import Document
            doc = Document(file_path)
            return {"Document Title": doc.core_properties.title}
        elif file_path.endswith('.ppt'):
            from pptx import Presentation
            prs = Presentation(file_path)
            return {"Presentation Title": prs.core_properties.title}
        elif file_path.endswith('.xls'):
            import xlrd
            wb = xlrd.open_workbook(file_path)
            return {"Excel Sheets": wb.sheet_names()}
        elif file_path.endswith('.pdf'):
            return extract_pdf_metadata(file_path)
        else:
            return {"Error": "Unsupported document type."}
    except Exception as e:
        return {"Error": str(e)}


def extract_metadata(file_path):
    """Extract metadata based on file type."""
    file_type = get_file_type(file_path)
    metadata = {"File Type": file_type}
    
    # Check file type and process accordingly
    if "PDF" in file_type.upper():
        metadata.update(extract_pdf_metadata(file_path))
    elif "JPEG" in file_type.upper() or "PNG" in file_type.upper() or "GIF" in file_type.upper():
        metadata.update(extract_image_metadata(file_path))
    elif "ZIP" in file_type.upper() or "RAR" in file_type.upper() or "7Z" in file_type.upper() or "ISO" in file_type.upper():
        metadata.update(extract_zip_metadata(file_path))
    elif "MP3" in file_type.upper() or "MP4" in file_type.upper():
        metadata.update(extract_audio_metadata(file_path))
    elif "PE32" in file_type.upper() or "DLL" in file_type.upper():
        metadata.update(extract_pe_metadata(file_path))
    elif "Microsoft Word" in file_type or "Excel" in file_type or "PowerPoint" in file_type:
        metadata.update(extract_document_metadata(file_path))
    else:
        metadata["Message"] = "No specific handler for this file type."
    
    return metadata


def generate_report(file_path):
    """Perform static malware analysis and generate a report."""
    # Use the same directory as the script for output
    script_directory = os.path.dirname(os.path.abspath(__file__))
    report_file = os.path.join(script_directory, "analysis_report.txt")

    try:
        file_hash = calculate_file_hash(file_path)
        file_metadata = extract_metadata(file_path)
        suspicious_strings = detect_suspicious_strings(file_path)
        llm_analysis = analyze_with_llm(suspicious_strings)
        virus_total_results = virus_total_hash_lookup(file_hash)

        # Write the results to a report file
        with open(report_file, 'w') as report:
            report.write(f"Analysis Report for {file_path}:\n")
            report.write(f"File Hash: {file_hash}\n")
            report.write(f"File Type: {file_metadata['File Type']}\n")
            report.write("File Metadata:\n")
            for key, value in file_metadata.items():
                if key != 'File Type':  # Skip the file type line as it's already printed
                    report.write(f"  {key}: {value}\n")
            report.write("Suspicious Strings Detected:\n")
            for string in suspicious_strings:
                report.write(f"  {string}\n")
            report.write("LLM Analysis:\n")
            for string, sentiment, confidence in llm_analysis:
                report.write(f"  {string}: {sentiment} (Confidence: {confidence:.2f})\n")
            report.write("VirusTotal Analysis:\n")
            if "Error" in virus_total_results:
                report.write(f"  {virus_total_results['Error']}\n")
            else:
                report.write(f"  Detected: {virus_total_results['VirusTotal Detected']} out of {virus_total_results['VirusTotal Scan Count']} scans.\n")

        print(f"Analysis report generated: {report_file}")
    except Exception as e:
        print(f"Error generating report: {str(e)}")

file_path = input("Enter the file path: ")
generate_report(file_path)